# ELF



## - overview

>Program structure: Create a C project with a Makefile. Your program should be named ft_nm and compile using the Makefile.
>
>Use your library: If you have an existing 'libft' (custom C library) from previous projects, make sure to include it at the root of your repository. Your Makefile should compile this library before compiling the ft_nm program.
>
>Implement ft_nm: Write a C program that replicates the functionality of the 'nm' command without any options. You should use the following system calls and functions:
>
>
>open(2)
>close(2)
>mmap(2)
>munmap(2)
>write(2)
>fstat(2)
>malloc(3)
>free(3)
>Support various binary formats: Your implementation should handle different ELF binary formats, including x86_32, x64, object files, and .so files. Use the 'file' command to inspect the details of these files.
>
>Output: Ensure that the output of your ft_nm program is similar to the original 'nm' command in terms of the symbols list (order, offset, padding, etc.). However, some minor differences in other aspects (e.g., filename) are acceptable.
>
>Error handling: Your program must handle errors carefully and should not crash unexpectedly (e.g., segmentation fault, bus error, double free, etc.).
>
>Validate parsed values: Make sure that all parsed values, such as flags and architecture, are correct by comparing them with a reference.
>
>Be cautious with memory: Pay attention to memory boundaries and ensure that your program does not access memory outside the mapped content. Check for non-null terminated strings, incorrect offsets, and other potential issues.
>
>Once you have implemented and tested your ft_nm program, you should have a working version of the 'nm' command that can display the symbol table of ELF binaries with various formats. This project will help you improve your C programming skills, learn about ELF binaries, and understand the functionality of the 'nm' command in Linux.


## - functioning of nm

>At a high level, the nm command works as follows:
>
>- Input: You provide the nm command with an object file, shared library, or executable as its input. These files are usually generated by a compiler or linker and contain the compiled code and associated metadata.
>
>- Parsing: The nm utility reads and parses the input file, recognizing the file format (e.g., ELF, COFF, Mach-O) and interpreting the associated metadata. It then locates the symbol table within the file, which is a data structure that stores information about the symbols defined in the file.
>
>- Extracting Symbols: The nm command reads the symbol table and extracts the relevant information for each symbol, such as its name, address, type, and other attributes. Symbols in a file can represent functions, global variables, constants, or other named entities.
>
>- Formatting and Output: Finally, the nm utility formats the extracted symbol information in a human-readable format and displays it on the console. The default output includes the symbol address, type (e.g., function, object, or other types), and name. You can customize the output using various command-line options, such as sorting the symbols alphabetically, displaying only specific types of symbols, or demangling C++ names.



## - wtf is symbol table

>- A symbol table is a data structure used by compilers, linkers, and other programming tools to store and manage information about the named entities (also called symbols) in a program's source code. >These named entities can include variables, functions, classes, constants, and other identifiers. Symbol tables are crucial for various stages of the compilation process, such as semantic analysis, code generation, and linking.
>
>A symbol table typically contains the following information for each symbol:
>
>Name: The identifier or name of the symbol, as it appears in the source code.
>Type: The data type of the symbol (e.g., integer, floating-point, array, or function).
>Scope: The scope or visibility of the symbol, such as global, local, or within a specific function or class.
>Address/Offset: The memory location or offset where the symbol is stored, either in the source code or the compiled binary.
>Attributes: Other properties related to the symbol, such as its storage class (e.g., static or extern), linkage, or alignment.
>Symbol tables are used in different stages of the compilation process for various purposes:
>
>During the semantic analysis, the compiler uses the symbol table to check the correctness of the source code, such as verifying that a variable is declared before it's used, or ensuring that a function >call matches the function's definition.
>During code generation, the compiler uses the symbol table to determine the memory locations or offsets for the symbols in the compiled code, as well as generate appropriate instructions for accessing >them.
>During linking, the linker combines the symbol tables of different object files to resolve external references, calculate final memory addresses, and create the final executable or shared library.
>By maintaining information about the symbols in a program, symbol tables play a crucial role in ensuring the correctness and efficiency of the compiled code.
>
---

- so i need to parse something..
