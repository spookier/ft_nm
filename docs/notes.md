# ELF



## - overview

>Implement ft_nm: Write a C program that replicates the functionality of the 'nm' command without any options. You should use the following system calls and functions:
>
>
>open(2)
>close(2)
>mmap(2)
>munmap(2)
>write(2)
>fstat(2)
>malloc(3)
>free(3)
>Support various binary formats: Your implementation should handle different ELF binary formats, including x86_32, x64, object files, and .so files. Use the 'file' command to inspect the details of these files.
>
>Output: Ensure that the output of your ft_nm program is similar to the original 'nm' command in terms of the symbols list (order, offset, padding, etc.). However, some minor differences in other aspects (e.g., filename) are acceptable.
>
>Error handling: Your program must handle errors carefully and should not crash unexpectedly (e.g., segmentation fault, bus error, double free, etc.).
>
>Validate parsed values: Make sure that all parsed values, such as flags and architecture, are correct by comparing them with a reference.
>
>Be cautious with memory: Pay attention to memory boundaries and ensure that your program does not access memory outside the mapped content. Check for non-null terminated strings, incorrect offsets, and other potential issues.
>
>Once you have implemented and tested your ft_nm program, you should have a working version of the 'nm' command that can display the symbol table of ELF binaries with various formats. This project will help you improve your C programming skills, learn about ELF binaries, and understand the functionality of the 'nm' command in Linux.


## - functioning of nm

>At a high level, the nm command works as follows:
>
>- Input: You provide the nm command with an object file, shared library, or executable as its input. These files are usually generated by a compiler or linker and contain the compiled code and associated metadata.
>
>- Parsing: The nm utility reads and parses the input file, recognizing the file format (e.g., ELF, COFF, Mach-O) and interpreting the associated metadata. It then locates the symbol table within the file, which is a data structure that stores information about the symbols defined in the file.
>
>- Extracting Symbols: The nm command reads the symbol table and extracts the relevant information for each symbol, such as its name, address, type, and other attributes. Symbols in a file can represent functions, global variables, constants, or other named entities.
>
>- Formatting and Output: Finally, the nm utility formats the extracted symbol information in a human-readable format and displays it on the console. The default output includes the symbol address, type (e.g., function, object, or other types), and name. You can customize the output using various command-line options, such as sorting the symbols alphabetically, displaying only specific types of symbols, or demangling C++ names.



## - wtf is symbol table

>- A symbol table is a data structure used by compilers, linkers, and other programming tools to store and manage information about the named entities (also called symbols) in a program's source code. >These named entities can include variables, functions, classes, constants, and other identifiers. Symbol tables are crucial for various stages of the compilation process, such as semantic analysis, code generation, and linking.
>
>A symbol table typically contains the following information for each symbol:
>
>Name: The identifier or name of the symbol, as it appears in the source code.
>Type: The data type of the symbol (e.g., integer, floating-point, array, or function).
>Scope: The scope or visibility of the symbol, such as global, local, or within a specific function or class.
>Address/Offset: The memory location or offset where the symbol is stored, either in the source code or the compiled binary.
>Attributes: Other properties related to the symbol, such as its storage class (e.g., static or extern), linkage, or alignment.
>Symbol tables are used in different stages of the compilation process for various purposes:
>
>During the semantic analysis, the compiler uses the symbol table to check the correctness of the source code, such as verifying that a variable is declared before it's used, or ensuring that a function >call matches the function's definition.
>During code generation, the compiler uses the symbol table to determine the memory locations or offsets for the symbols in the compiled code, as well as generate appropriate instructions for accessing >them.
>During linking, the linker combines the symbol tables of different object files to resolve external references, calculate final memory addresses, and create the final executable or shared library.
>By maintaining information about the symbols in a program, symbol tables play a crucial role in ensuring the correctness and efficiency of the compiled code.
>
---



> - void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);

>Here's an explanation of each argument:

>void *addr: This is the desired starting address of the mapped region in the process's address space. If this argument is set to NULL, the operating system will choose the address. It's common practice to set this argument to NULL unless there's a specific reason to control the mapping address.

> size_t length: This specifies the length (in bytes) of the region that will be mapped into the address space. When mapping a file, this should be equal to or less than the file size.

>int prot: This argument defines the protection level for the mapped memory region. It can be a combination of the following flags:

>PROT_NONE: The region cannot be accessed.
PROT_READ: The region can be read.
PROT_WRITE: The region can be written.
PROT_EXEC: The region can be executed.
int flags: This argument provides additional options for the memory mapping. The most common flags are:

>MAP_SHARED: The mapping is shared between processes. Any changes made to the mapped region are visible to other processes that share the same mapping and are written back to the underlying file.
MAP_PRIVATE: The mapping is private to the process. Any changes made to the mapped region are not visible to other processes and are not written back to the underlying file. Instead, the system creates a private copy-on-write mapping, which means that any modifications to the mapped region are made in a private copy of the memory region and not in the shared file.
int fd: This is the file descriptor of the file you want to map into memory. You should open the file with the open() function before using mmap().

>off_t offset: This argument specifies the offset (in bytes) from the beginning of the file where the mapping should start. It's common to set this value to 0 to map the entire file from the beginning. Note that the offset must be a multiple of the system page size, which can be determined using sysconf(_SC_PAGESIZE).

>mmap returns a pointer to the start of the mapped memory region in the process's address space, or MAP_FAILED (usually defined as (void *)-1) in case of an error.

---

> e_shoff from Header file: This field contains the file offset (i.e., the number of bytes from the beginning of the file) at which the section header table starts

- Symbol table
![image](https://github.com/spookier/ft_nm/assets/77325667/d9e4a01f-78d7-4151-8485-fb251b1c5d5c)

